# -*- coding: utf-8 -*-
"""Streamlit Task Manager

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_ob_EowZWctIfO0gmfWMuQY5rDv6HXkL
"""

import streamlit as st
from datetime import datetime, timedelta
import calendar

# --- CONFIGURATION ---
# Task Types for the UI selection
TASK_TYPES = ['one-time', 'daily', 'weekly', 'bi-weekly', 'monthly']

# Initial Mock User data with roles
INITIAL_MOCK_USERS = [
    {'id': 'user_1', 'name': 'Mustafa (Admin)', 'role': 'admin'},
    {'id': 'user_2', 'name': 'Bob (Team Lead)', 'role': 'user'},
    {'id': 'user_3', 'name': 'Charlie (Member)', 'role': 'user'},
]

# Helper to get user name from ID
def get_user_name(user_id):
    """Retrieves the full name of a user based on their ID."""
    user = next((u for u in st.session_state.users if u['id'] == user_id), None)
    return user['name'] if user else f"Unknown User ({user_id})"

# --- FIREBASE / DATA SETUP (Currently using Session State) ---

def initialize_tasks():
    """Initializes the task list and user list in Streamlit session state."""
    # Initialize Users
    if 'users' not in st.session_state:
        st.session_state.users = INITIAL_MOCK_USERS.copy()

    # Initialize Tasks
    if 'tasks' not in st.session_state:
        st.session_state.tasks = [
            # Example Task 1 (One-Time for today, assigned to Alice)
            {
                'id': 'mock1',
                'title': 'Review Streamlit Code',
                'description': 'Check all functions and imports.',
                'due_date': datetime.now().date(),
                'type': 'one-time',
                'owner_id': 'user_1',
                'is_completed': False,
            },
            # Example Task 2 (Weekly Recurrent, assigned to Bob)
            {
                'id': 'mock2',
                'title': 'Weekly Report Prep',
                'description': 'Prepare slide deck for management.',
                'due_date': datetime.now().date() - timedelta(days=2), # Starts 2 days ago
                'type': 'weekly',
                'owner_id': 'user_2',
                'is_completed': False,
            },
            # Example Task 3 (Monthly Recurrent, assigned to Charlie)
            {
                'id': 'mock3',
                'title': 'Clean Database',
                'description': 'Routine maintenance.',
                'due_date': datetime.now().date().replace(day=5), # Starts on the 5th of the month
                'type': 'monthly',
                'owner_id': 'user_3',
                'is_completed': False,
            }
        ]

    # Initialize Current User
    if 'current_user_id' not in st.session_state:
        st.session_state.current_user_id = INITIAL_MOCK_USERS[0]['id']


# --- RECURRENCE LOGIC (Python Implementation) ---

def day_difference(date1, date2):
    """Calculates the difference in days between two date objects."""
    return abs((date2 - date1).days)

def is_task_due(task, target_date):
    """Checks if a task is due on a specific target date based on its recurrence type."""
    start_date = task['due_date']
    task_type = task['type']

    # Must not be due before it starts
    if target_date < start_date:
        return False

    # Always due on the start date
    if target_date == start_date:
        return True

    if task_type == 'one-time':
        return False

    if task_type == 'daily':
        return True

    if task_type == 'weekly':
        return target_date.weekday() == start_date.weekday()

    if task_type == 'bi-weekly':
        # Check if difference is divisible by 14
        days_between = day_difference(target_date, start_date)
        return days_between % 14 == 0

    if task_type == 'monthly':
        return target_date.day == start_date.day

    return False

def get_next_occurrence(task, reference_date, days_limit=365):
    """Finds the next occurrence of a task within a days_limit."""

    next_date = reference_date
    end_date = reference_date + timedelta(days=days_limit)

    while next_date < end_date:
        if is_task_due(task, next_date):
            return next_date
        next_date += timedelta(days=1)

    return None

# --- UI COMPONENTS ---

def task_card(task, next_due_date, current_view, on_complete=None):
    """Displays a single task card."""
    is_recurrent = task['type'] != 'one-time'
    recurrence_text = f"Repeats {task['type'].replace('-', ' ')}" if is_recurrent else 'One-time'

    # Determine card styling
    if task['is_completed']:
        card_style = "opacity: 0.6; background-color: #e5e7eb;"
        title_style = "text-decoration: line-through; color: #6b7280;"
    elif is_recurrent:
        card_style = "border-left: 4px solid #34d399; background-color: #ecfdf5;"
        title_style = "color: #1f2937;"
    else:
        card_style = "border-left: 4px solid #f87171; background-color: #fef2f2;"
        title_style = "color: #1f2937;"

    col1, col2, col3 = st.columns([0.6, 0.2, 0.2])

    owner_name = get_user_name(task['owner_id'])

    with col1:
        st.markdown(f'<div style="{title_style} font-weight: bold; font-size: 16px;">{task["title"]}</div>', unsafe_allow_html=True)
        st.caption(f"Owned by: **{owner_name}** | {task['description'] if task['description'] else 'No description.'}")

    with col2:
        if next_due_date:
            st.markdown(f'<div style="font-weight: bold; font-size: 14px; text-align: right;">{next_due_date.strftime("%b %d")}</div>', unsafe_allow_html=True)
            st.markdown(f'<div style="font-size: 10px; text-align: right; color: #6b7280; text-transform: uppercase;">{recurrence_text}</div>', unsafe_allow_html=True)

    with col3:
        # Completion toggle logic: only owner can toggle, and only in Dashboard actionable views
        if current_view != 'All My Tasks' and task['owner_id'] == st.session_state.current_user_id:
            if not task['is_completed']:
                st.button("Done", key=f"complete_{task['id']}_{current_view}", on_click=on_complete, args=(task['id'],))
            else:
                st.button("Un-do", key=f"uncomplete_{task['id']}_{current_view}", on_click=on_complete, args=(task['id'],))


    st.markdown("---") # Simple separator

def add_task_form():
    """Form for adding new tasks with conditional assignment."""

    # 1. Get current user info and role
    current_user_id = st.session_state.current_user_id
    current_user_info = next(u for u in st.session_state.users if u['id'] == current_user_id)
    is_admin = current_user_info['role'] == 'admin'

    with st.expander("‚ûï Add New Task"):
        with st.form("new_task_form", clear_on_submit=True):
            title = st.text_input("Title", key="title_input")
            description = st.text_area("Description (Optional)", key="desc_input")

            # Recurrence and Date Column
            cols = st.columns(2)
            with cols[0]:
                due_date = st.date_input("Due/Start Date", value=datetime.now().date(), key="date_input")
            with cols[1]:
                task_type = st.selectbox("Recurrence", TASK_TYPES, key="type_select")

            # Assignment Logic
            if is_admin:
                st.markdown("---")
                # Admin can assign to any user
                all_users_options = [(user['name'], user['id']) for user in st.session_state.users]
                all_user_names = [name for name, _ in all_users_options]
                selected_assignee_name = st.selectbox("Assignee (Admin Only)", all_user_names, key="assignee_select")
                assignee_id = next(u_id for u_name, u_id in all_users_options if u_name == selected_assignee_name)
            else:
                # Normal user is assigned the task automatically
                assignee_id = current_user_id
                st.caption(f"Task will be assigned to: **{current_user_info['name']}**")

            submitted = st.form_submit_button("Save Task", type="primary")

            if submitted and title:
                # Add task to session state
                new_id = f"task_{len(st.session_state.tasks) + 1}"
                st.session_state.tasks.append({
                    'id': new_id,
                    'title': title,
                    'description': description,
                    'due_date': due_date,
                    'type': task_type,
                    'owner_id': assignee_id, # Use the determined assignee ID
                    'is_completed': False,
                })
                st.success(f"Task '{title}' added and assigned to {get_user_name(assignee_id)}!")
            elif submitted and not title:
                 st.error("Task title cannot be empty.")

def admin_only_user_management(current_user_id):
    """Admin-only interface for creating users."""
    user_info = next(u for u in st.session_state.users if u['id'] == current_user_id)
    is_admin = user_info['role'] == 'admin'

    if is_admin:
        st.header("Admin Tools")
        with st.expander("üë§ Create/View Users"):
            st.markdown("##### Current Users")
            st.dataframe(st.session_state.users, use_container_width=True)

            st.markdown("##### Add New User")
            with st.form("new_user_form", clear_on_submit=True):
                new_user_name = st.text_input("New User Name", key="new_user_name_input")
                new_user_role = st.selectbox("Role", ['user', 'admin'], key="new_user_role_select")

                submitted = st.form_submit_button("Create User", type="secondary")

                if submitted and new_user_name:
                    new_id = f"user_{len(st.session_state.users) + 1}"
                    # Append role to name for clarity in the UI list
                    display_name = new_user_name + (f" ({new_user_role.capitalize()})" if new_user_role == 'admin' else ' (Member)')
                    st.session_state.users.append({
                        'id': new_id,
                        'name': display_name,
                        'role': new_user_role
                    })
                    st.success(f"User '{display_name}' created!")

# --- VIEWS ---

def dashboard_view():
    """Displays the Dashboard view with Today and Upcoming tasks (filtered by current user)."""
    st.subheader("Actionable Summary (My Tasks)")

    today = datetime.now().date()

    current_user_id = st.session_state.current_user_id
    # Dashboard always filters to only show tasks owned by the current user
    user_tasks = [task for task in st.session_state.tasks if task['owner_id'] == current_user_id]

    # 1. Calculate next due dates for all tasks
    tasks_with_next_date = []
    for task in user_tasks:
        next_date = get_next_occurrence(task, today, 365)
        if next_date:
            tasks_with_next_date.append({
                **task,
                'next_due_date': next_date,
            })

    # 2. Filter into sections
    tasks_due_today = sorted(
        [t for t in tasks_with_next_date if t['next_due_date'] == today],
        key=lambda x: x['title']
    )

    upcoming_tasks = sorted(
        [t for t in tasks_with_next_date if today < t['next_due_date'] <= today + timedelta(days=7)],
        key=lambda x: x['next_due_date']
    )

    all_user_tasks = sorted(
        tasks_with_next_date,
        key=lambda x: x['next_due_date']
    )

    def toggle_task_completion(task_id):
        """Toggles the completion status of a task by its ID."""
        for task in st.session_state.tasks:
            if task['id'] == task_id:
                task['is_completed'] = not task['is_completed']
                st.toast(f"Task '{task['title']}' updated!")
                break
        st.experimental_rerun()

    # --- RENDER DASHBOARD SECTIONS ---

    st.markdown("### üéØ Tasks Due Today")
    if tasks_due_today:
        for task in tasks_due_today:
            task_card(task, task['next_due_date'], "Today", toggle_task_completion)
    else:
        st.info(f"Nothing due today for {get_user_name(current_user_id)}! üéâ")

    st.markdown("---")

    st.markdown("### üóìÔ∏è Upcoming Tasks (Next 7 Days)")
    if upcoming_tasks:
        for task in upcoming_tasks:
            task_card(task, task['next_due_date'], "Upcoming", toggle_task_completion)
    else:
        st.info(f"No upcoming tasks this week for {get_user_name(current_user_id)}.")

    st.markdown("---")

    st.markdown("### üìù All My Tasks")
    if all_user_tasks:
        for task in all_user_tasks:
            # Task completion is only allowed in the 'Today' and 'Upcoming' actionable lists
            task_card(task, task['next_due_date'], "All My Tasks", None)
    else:
        st.warning(f"{get_user_name(current_user_id)} has no tasks saved yet. Add one above!")


def calendar_view():
    """Displays the Calendar view with role-based filtering."""

    current_user_id = st.session_state.current_user_id
    current_user_info = next(u for u in st.session_state.users if u['id'] == current_user_id)
    is_admin = current_user_info['role'] == 'admin'

    st.subheader("Monthly Calendar")

    # Conditional Task Filter Control for Admin
    if is_admin:
        view_filter = st.radio(
            "Calendar View Filter",
            ('All Team Tasks', 'My Tasks'),
            key='calendar_filter_radio',
            horizontal=True
        )
    else:
        view_filter = 'My Tasks'
        st.caption("Showing tasks assigned to you.")

    # Set the list of tasks to check based on the filter
    if view_filter == 'All Team Tasks':
        tasks_to_check = st.session_state.tasks
    else: # 'My Tasks' (for both normal users and filtered admin view)
        tasks_to_check = [t for t in st.session_state.tasks if t['owner_id'] == current_user_id]

    # Current month navigation
    if 'calendar_date' not in st.session_state:
        st.session_state.calendar_date = datetime.now().date()

    col1, col2, col3 = st.columns([1, 2, 1])

    with col1:
        if st.button("‚Üê Previous Month"):
            # Move to the 1st of the previous month
            new_date = st.session_state.calendar_date.replace(day=1) - timedelta(days=1)
            st.session_state.calendar_date = new_date.replace(day=1)

    with col2:
        st.markdown(f"<h3 style='text-align: center;'>{st.session_state.calendar_date.strftime('%B %Y')}</h3>", unsafe_allow_html=True)

    with col3:
        if st.button("Next Month ‚Üí"):
            # Logic to correctly increment month
            next_month = st.session_state.calendar_date.month % 12 + 1
            next_year = st.session_state.calendar_date.year + (1 if next_month == 1 else 0)
            st.session_state.calendar_date = st.session_state.calendar_date.replace(month=next_month, year=next_year, day=1)

    st.markdown("---")

    current_date = st.session_state.calendar_date
    cal = calendar.Calendar(firstweekday=calendar.MONDAY)
    month_days = cal.monthdatescalendar(current_date.year, current_date.month)

    # Generate the calendar display
    days_names = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']

    # Render day names
    cols = st.columns(7)
    for i, day in enumerate(days_names):
        cols[i].markdown(f"**{day}**", help="Day of the week")

    # Render days
    for week in month_days:
        cols = st.columns(7)
        for i, day_date in enumerate(week):
            tasks_due = [t for t in tasks_to_check if is_task_due(t, day_date)]

            is_current_month = day_date.month == current_date.month
            is_today = day_date == datetime.now().date()

            style = ""
            if is_today:
                style = "background-color: #bfdbfe; border-radius: 8px; border: 2px solid #3b82f6;" # Light blue for today
            elif not is_current_month:
                style = "color: #9ca3af;" # Gray out non-month days

            task_summary = []
            for t in tasks_due:
                owner = get_user_name(t['owner_id']).split(' ')[0] # just use first name
                status = "‚úÖ" if t['is_completed'] else "‚òê"
                task_summary.append(f"{status} ({owner}): {t['title']}")

            content = f'<div style="text-align: center; height: 100%; padding: 5px; {style}">'
            content += f'<span style="font-weight: bold; font-size: 16px;">{day_date.day}</span><br>'

            if tasks_due:
                # Count total due tasks
                content += f'<span style="font-size: 12px; font-weight: bold; color: #10b981;">{len(tasks_due)} tasks</span>'
            else:
                content += '<span style="font-size: 10px; color: #9ca3af;">-</span>'

            content += '</div>'
            cols[i].markdown(content, unsafe_allow_html=True, help='\n'.join(task_summary) or "No tasks due.")

# --- MAIN APPLICATION ---

def main():
    """Main function to run the Streamlit app."""
    st.set_page_config(layout="wide", page_title="TaskFlow Manager")
    st.title("TaskFlow Manager")

    # Initialize data store and user state
    initialize_tasks()

    # Sidebar for navigation and user info
    with st.sidebar:
        st.header("Navigation")
        view = st.radio("Select View", ['Dashboard', 'Calendar'])
        st.markdown("---")

        # User Selection Interface (Login)
        st.subheader("Current User")

        # Get list of user names for the selectbox
        user_names = [user['name'] for user in st.session_state.users]

        # Set default to the currently logged in user for persistence
        current_user_name = get_user_name(st.session_state.current_user_id)

        selected_user_name = st.selectbox(
            "Select your profile:",
            options=user_names,
            index=user_names.index(current_user_name) if current_user_name in user_names else 0,
            key='current_user_name_select'
        )

        # Find the ID for the selected name and update session state
        current_user = next(user for user in st.session_state.users if user['name'] == selected_user_name)
        st.session_state.current_user_id = current_user['id']

        st.info(f"**Logged in as:** {current_user['name']} ({current_user['role'].capitalize()})")
        st.caption("Tasks are currently saved in browser session state.")

        st.markdown("---")

        # Admin User Creation Tools (Only visible to Admins)
        admin_only_user_management(st.session_state.current_user_id)


    add_task_form()
    st.markdown("---")

    if view == 'Dashboard':
        dashboard_view()
    elif view == 'Calendar':
        calendar_view()

if __name__ == "__main__":
    main()